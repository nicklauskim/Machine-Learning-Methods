# -*- coding: utf-8 -*-
"""homework2-code.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1AAd6hwnlWTPCkY-0ujnKk118h1_fAr0B
"""

import numpy as np
from scipy import linalg
import matplotlib.pyplot as plt

from sklearn.metrics import roc_auc_score

def sigmoid(x):
  return 1 / (1 + np.exp(-x))

# Generate random variables
x = np.random.uniform(0, 1, size=(1000, 2))
y = np.array([1. if (xi[0]**2 + xi[1]**2 <= 1) else 0. for xi in x]).astype('float32')

x

y[:10]

plt.scatter(x[:, 0], x[:, 1], c=y, cmap='Paired_r')

# Indices of data points in the current region
def in_region(data, region):
  '''
  data: an array of size (n, 2)
  region: an array of size (1, 2**2)
  returns array
  '''
  return np.where((region[0] <= data[:, 0]) & (data[:, 0] < region[1]) & (region[2] <= data[:, 1]) & (data[:, 1] < region[3]))

def decision_tree(x, y):
  all_preds = np.zeros_like(y)
  shat = y
  for p in range(1):
    preds = np.zeros_like(y)
    regions = np.array([0, 1, 0, 1]).reshape((1, 4))
    for num in range(1):
      new_regions = np.zeros((1, 4))
      region_to_delete = -1
      for i, M in enumerate(regions):
        x_in_region = x[in_region(x, M)]
        min_loss = np.infty
        losses = np.array((2, 0))
        for j in [0, 1]:
          # We don't want to consider the "end points", i.e. we shouldn't cut off at a leftmost or rightmost point, we would then be creating an empty region...
          possible_cutoffs = np.sort(x_in_region[:, j])[1:-1]
          for xij in possible_cutoffs:
            added_loss = 0
            # Define cut/new region to make
            if (j == 0):
              new_region_1 = np.array([M[0], xij, M[2], M[3]]).reshape((4, ))
              new_region_2 = np.array([xij, M[1], M[2], M[3]]).reshape((4, ))
            if (j == 1):
              new_region_1 = np.array([M[0], M[1], xij, M[3]]).reshape((4, ))
              new_region_2 = np.array([M[0], M[1], M[2], xij]).reshape((4, ))  
            
            for new_region in [new_region_1, new_region_2]:
              new_idx = in_region(x, new_region)
              phat = np.mean(y[new_idx])
              added_loss += np.sum((shat[new_idx] - phat)**2)

            if added_loss < min_loss:   
              #print("this is the best cutoff SO FAR")
              min_loss = added_loss

              good_region_1 = new_region_1
              good_region_2 = new_region_2

              new_idx_1 = in_region(x, good_region_1)
              new_idx_2 = in_region(x, good_region_2)

              phat_1 = np.mean(y[new_idx_1])
              phat_2 = np.mean(y[new_idx_2])

          preds[in_region(x, good_region_1)] = phat_1
          preds[in_region(x, good_region_2)] = phat_2

          new_regions = np.vstack([new_regions[:-2], good_region_1, good_region_2])
          region_to_delete = i
            
      # Change regions here
      regions = np.delete(regions, region_to_delete, axis=0)
      regions = np.vstack([regions, new_regions], )

  return preds

def xg_wu(x, y, num):
  preds = decision_tree(x, y)
  resid = y - sigmoid(preds)
  for i in range(num):
    preds += decision_tree(x, resid)
    #print(preds[:10])
    print(roc_auc_score(y, sigmoid(preds)))
    resid = y - sigmoid(preds)
  return sigmoid(preds)

good_preds = xg_wu(x, y, 100)
preds_list = [1. if p >= 0.5 else 0. for p in good_preds]

plt.scatter(x[:, 0], x[:, 1], c=preds_list, cmap='Paired_r')

